# 9장 설계 절차

## 목차

1. 몇가지 설계 충고
2. 기존 API에 하이퍼미디어 추가하기
3. 앨리스의 두 번째 모험
4. 질문

- 저자가 겪은 설계 과정 교훈 얘기

### 1. 몇가지 설계 충고

- 리소스는 구현의 구체적인 내용이다

  - 설계 과정은 상태 전이와 의미 체계 서술자에 집중한다 -> 그럼 리소스는 알아서 해결된다.

- 컬렉션 함정에 빠지지 말라

  - 데이터베이스 스키마를 기반으로 API 를 설계하지 마라. 대신 상태 다이에그램을 그려라.
  - why?
    - 사용자들이 데이터베이스 스키마를 전혀 고려하지 않는다. (어플리케이션과 데이터베이스는 다른 것)
    - 요구 사항이 변경됨에 따라 스키마를 변결할 수 있는 권리를 서버 개발자가 가지고 있음 -> 설계를 디비 스키마 기준으로하면 API 바꾸는게 힘들어짐

- 표현 형식에서 시작하지 않는다

  - 저자가 앞서 말한 7단계 원칙을 차례대로 따라가라.

- URL 설계는 상관이 없다

  - URI 템플릿을 지원하는 표현 형식을 제공한다면, 문서를 동등한 하이퍼미디어 컨트롤로 교체할 수 있디.

- 표준 이름이 직접 지은 이름보다 낫다

  - 표준 제작자들이 다 잘 지어두었다.

- 미디어 유형을 설계해야 한다면

  - 미디어 유형은 반드시 완전하고 모호함이 엇는 처리 설명서가 포함되어야 한다.
  - 단일 API를 위해 여러 미디어 유형을 정의하고 있다면? -> 일반적인 하이퍼미디어 유형을 사용하거나, 새로운 미디어 유형 하나를 정의 하고 프로파일을 등록해라
  - RFC6838 참고 - 이름 정하는 방법
  - 등록 양식 고려사항들 p.221 참고

- API 를 변경해야 할 때

  - 더 좋은 하이퍼미디어 포멧을 선택할 수록 더욱 클라이언트에 영향을 주지 않고 API로 새로운 리소스와 상태 전이를 추가할 수 있다!
  - 하지만 변경이 클라이언트 수정 없이 한번에 되기는 힘들다. API 개발자는 클라이언트가 변경 사항에 대응할 수 있도록 버전을 분기 해야만 한다.
  - 3가지 분기 전략

    1. URL 공간 분리
    2. 미디어 유형의 버전 만들기
    3. 프로파일 버전 만들기

  - 버전 만들기는 특별하지 않다
    - 클라이언트가 적응할 수 있는 부분과, 클라이언트가 망가질 수 있는 부분을 깔끔하게 분리한다.
  - 수명이 있는 계획을 만든다
  - 한 곳에 모든 하이퍼미디어를 유지하지 마라
    - 버튼만 누르면 서버 구현을 검사하고 하이퍼미디어 기반 서비스 문서가 설명하는 API를 생성해 주는 도구가 있다? -> [찾은 예시](https://m.blog.naver.com/tmondev/220391644590)
    - 안티 패턴: OData, WADL, 히드라

## 2. 기존 API에 하이퍼미디어 추가하기

- 우선 기존 리소스들을 저자가 앞서 말한 7단계 설계 절차에 의거해 다시 설계하긴 해야한다. (4단계 미디어 유형만 applicaion/json 고정)

- 이런 수고를 할 가치가 있는가?
  - 이득은 단지 "만족감" 뿐이다

## 3. 앨리스의 두 번째 모험

- 자신이 만든 미디어 유형을 기계가 어떻게 자동적으로 이해하는지에 대한 플로우를 설명.
- p.232 ~ 237 참고

## 질문

### Q1.

> 최준영
> 여러 개의 리소스를 식별하도록 설계된 API에 대해서 어떻게 생각하시나요? 일반적인 설계인가요?
> ex) POST /user/{userId}/account/{accountId}/code

### A1.

해당 API 는 어떤 리소스에 대한 요청인지 불분명하다는 단점이 있는 것 같다.
2단계 설계 절차에서 상태 전이가 일어나는 부분을 쪼개주었듯이, 하나의 리소스에 여러개의 형태의 상태 전이가 있으면 분리해주는 것이 좋을 거 같다.
상태 전이가 일어나는 리소스인 user 와 account 를 각각 독립적인 리소스로 설계해주면 account 리소스에 대한 요청으로 명확하게 구분될 것 같다.

### Q2.

> 한태혁
> 책에서 문서 변경이 있을 때의 버전 관리 전략에 대해 설명해줬는데
> 이게 사소한 변경에도 새로운 버전을 만들어야 하는지, 혹은 기존과 완전히 다른 변경이 있을 때만 새로운 버전을 만들어야 하는 것인지,
> 그 버전을 나누는 일반적인 기준이 있는지 궁금합니다

### A2.

- 책에서도 가장 뜨거운 주제중 하나라 할 만큼 정해진 답은 없는 것 같다.
- 책에서는 그 이유가 하이퍼 미디어 기반의 설계를 해야하는 점이라고 강조하고 있다
- 좋은 하이퍼미디어 포맷을 선택하면 기존 클라이언트에 영향을 주지 않고 API로 새로운 리소스와 상태 전이를 추가할 수 있다.

### Q3.

> 박근영
> 책에서 API 변경에 대해 3가지 전략을 소개해줬는데, 어떤 상황에 어떤 방법을 사용하는 것이 좋을까요

### A3.

- URL 공간 분리

  - 책에 나온 하이퍼 미디어 기반의 설계를 하지 않았으면 사실상 가능한 유일한 방법

- 미디어 유형의 버전 만들기 (내가 정의한 미디어 유형의 한하여 가능)

  - 나의 어플리케이션에서 미디어 유형이 진짜 많은 부분을 결정지어 버릴 떄
  - 의미 체계가 변경되었을 때

- 프로파일 버전 만들기 (하이퍼 미디어 기반의 설계와 그렇지 못한 설계가 공존할 때)
  - 하이퍼 미디어에 기반하지 않은 클라이언트 영역은 대응하기 전까지 이전 프로파일 버전을 사용하도록 한다.

### Q4.

> 곽재영
> HTML 버전 3.0은 version 매개 변수를 사용했지만, 이는 HTML 4에서 제거되었고,
> 현재의 HTML 5는 HTML 4와 매우 다르지만 이들은 하위 호환성을 가지고 있다고 합니다. (p. 224)
> 여기서 이전 버전에서는 왜 version 매개 변수가 필요했고, version 매개 변수가 제거된 지금의 버전에서는
> 어떻게 하위 호환성을 가지도록 하는 지 궁금합니다.

### A4.

- [HTML3.0](https://www.w3.org/MarkUp/html3/intro.html)
- HTML3.0 버전까지는 하위호환성이 유지가 안되어 version 이 필요했던 것.

- HTML4 랑 HTML5 는 어덯게 하위호환성을 유지하는가?
- [Search Labs | AI Overview](https://en.wikipedia.org/wiki/HTML5#:~:text=HTML5%20was%20first%20released%20in,low%2Dpowered%20devices%20in%20mind.)
- [HTML5 와 HTML4 의 차이](https://www.w3.org/TR/html5-diff/)

### Q5.

> 임해찬
> 특정 API 버전의 지원이 중단됨을 알릴 수 있는 방법이 따로 있을까요? 일반적인 방법이나 사례를 찾아주시면 감사하겠습니다.

### A5.

책에 예시로 나왔듯이 일반적인 방법으로는 HTTP 응답코드 중 410이 이에 해당한다. p.227
[참고](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/410)

### Q6.

> 서형석
> 이번 장에서 주요하게 다뤄지는 원칙 하나가 '의존성의 분리'인것 같습니다.
> 데이터베이스 스키마에 기반을 둔 API를 게시하지 말자. 그렇지 않으면 데이터베이스에 따른 소프트웨어 의존성을 부여하게 된다.
> API에서 사람이 이해할 수 있는 문서의 양을 줄여 API 변경시 대응해야하는 부분을 줄인다
> 그렇다면, 책에서 서술한 내용이 아닌 것 중에 추가로 의존성을 분리하여 API 변경시 대응할 부분을 최소화시키는 영역이 또 어떤 것이 있을까요?

### A6.

책의 서술된 내용 외를 질문 주셔서 기본적인 스프링 의존성 관리 기법을 가져와 봤습니다.
[생성자 주입](https://programforlife.tistory.com/111)
